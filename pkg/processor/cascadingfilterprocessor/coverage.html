
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cascadingfilterprocessor: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/open-telemetry/opentelemetry-collector-contrib/processor/cascadingfilterprocessor/factory.go (100.0%)</option>
				
				<option value="file1">github.com/open-telemetry/opentelemetry-collector-contrib/processor/cascadingfilterprocessor/idbatcher/id_batcher.go (100.0%)</option>
				
				<option value="file2">github.com/open-telemetry/opentelemetry-collector-contrib/processor/cascadingfilterprocessor/metrics.go (93.8%)</option>
				
				<option value="file3">github.com/open-telemetry/opentelemetry-collector-contrib/processor/cascadingfilterprocessor/processor.go (82.6%)</option>
				
				<option value="file4">github.com/open-telemetry/opentelemetry-collector-contrib/processor/cascadingfilterprocessor/sampling/policy_factory.go (0.0%)</option>
				
				<option value="file5">github.com/open-telemetry/opentelemetry-collector-contrib/processor/cascadingfilterprocessor/sampling/policy_filter.go (93.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright The OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cascadingfilterprocessor

import (
        "context"
        "time"

        "go.opencensus.io/stats/view"
        "go.opentelemetry.io/collector/component"
        "go.opentelemetry.io/collector/config"
        "go.opentelemetry.io/collector/config/configtelemetry"
        "go.opentelemetry.io/collector/consumer"
        "go.opentelemetry.io/collector/processor/processorhelper"

        cfconfig "github.com/open-telemetry/opentelemetry-collector-contrib/processor/cascadingfilterprocessor/config"
)

const (
        // The value of "type" Cascading Filter in configuration.
        typeStr = "cascading_filter"
)

var (
        defaultProbabilisticFilteringRatio = float32(0.2)
)

// NewFactory returns a new factory for the Cascading Filter processor.
func NewFactory() component.ProcessorFactory <span class="cov6" title="2">{
        // TODO: this is hardcoding the metrics level and skips error handling
        _ = view.Register(CascadingFilterMetricViews(configtelemetry.LevelNormal)...)

        return processorhelper.NewFactory(
                typeStr,
                createDefaultConfig,
                processorhelper.WithTraces(createTraceProcessor))
}</span>

func createDefaultConfig() config.Processor <span class="cov10" title="3">{
        return &amp;cfconfig.Config{
                ProcessorSettings: &amp;config.ProcessorSettings{
                        TypeVal: typeStr,
                        NameVal: typeStr,
                },
                DecisionWait:                30 * time.Second,
                NumTraces:                   50000,
                SpansPerSecond:              1500,
                ProbabilisticFilteringRatio: &amp;defaultProbabilisticFilteringRatio,
        }
}</span>

func createTraceProcessor(
        _ context.Context,
        params component.ProcessorCreateParams,
        cfg config.Processor,
        nextConsumer consumer.Traces,
) (component.TracesProcessor, error) <span class="cov1" title="1">{
        tCfg := cfg.(*cfconfig.Config)
        return newTraceProcessor(params.Logger, nextConsumer, *tCfg)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright The OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package idbatcher defines a pipeline of fixed size in which the
// elements are batches of ids.
package idbatcher

import (
        "errors"
        "sync"

        "go.opentelemetry.io/collector/consumer/pdata"
)

var (
        // ErrInvalidNumBatches occurs when an invalid number of batches is specified.
        ErrInvalidNumBatches = errors.New("invalid number of batches, it must be greater than zero")
        // ErrInvalidBatchChannelSize occurs when an invalid batch channel size is specified.
        ErrInvalidBatchChannelSize = errors.New("invalid batch channel size, it must be greater than zero")
)

// Batch is the type of batches held by the Batcher.
type Batch []pdata.TraceID

// Batcher behaves like a pipeline of batches that has a fixed number of batches in the pipe
// and a new batch being built outside of the pipe. Items can be concurrently added to the batch
// currently being built. When the batch being built is closed, the oldest batch in the pipe
// is pushed out so the one just closed can be put on the end of the pipe (this is done as an
// atomic operation). The caller is in control of when a batch is completed and a new one should
// be started.
type Batcher interface {
        // AddToCurrentBatch puts the given id on the batch being currently built. The client is in charge
        // of limiting the growth of the current batch if appropriate for its scenario. It can
        // either call CloseCurrentAndTakeFirstBatch earlier or stop adding new items depending on what is
        // required by the scenario.
        AddToCurrentBatch(id pdata.TraceID)
        // CloseCurrentAndTakeFirstBatch takes the batch at the front of the pipe, and moves the current
        // batch to the end of the pipe, creating a new batch to receive new items. This operation should
        // be atomic.
        // It returns the batch that was in front of the pipe and a boolean that if true indicates that
        // there are more batches to be retrieved.
        CloseCurrentAndTakeFirstBatch() (Batch, bool)
        // Stop informs that no more items are going to be batched and the pipeline can be read until it
        // is empty. After this method is called attempts to enqueue new items will panic.
        Stop()
}

var _ Batcher = (*batcher)(nil)

type batcher struct {
        pendingIds chan pdata.TraceID // Channel for the ids to be added to the next batch.
        batches    chan Batch         // Channel with already captured batches.

        // cbMutex protects the currentBatch storing ids.
        cbMutex      sync.Mutex
        currentBatch Batch

        newBatchesInitialCapacity uint64
        stopchan                  chan bool
        stopped                   bool
}

// New creates a Batcher that will hold numBatches in its pipeline, having a channel with
// batchChannelSize to receive new items. New batches will be created with capacity set to
// newBatchesInitialCapacity.
func New(numBatches, newBatchesInitialCapacity, batchChannelSize uint64) (Batcher, error) <span class="cov2" title="5">{
        if numBatches &lt; 1 </span><span class="cov1" title="1">{
                return nil, ErrInvalidNumBatches
        }</span>
        <span class="cov2" title="4">if batchChannelSize &lt; 1 </span><span class="cov1" title="1">{
                return nil, ErrInvalidBatchChannelSize
        }</span>

        <span class="cov1" title="3">batches := make(chan Batch, numBatches)
        // First numBatches batches will be empty in order to simplify clients that are running
        // CloseCurrentAndTakeFirstBatch on a timer and want to delay the processing of the first
        // batch with actual data. This way there is no need for accounting on the client side and
        // a single timer can be started immediately.
        for i := uint64(0); i &lt; numBatches; i++ </span><span class="cov3" title="12">{
                batches &lt;- nil
        }</span>

        <span class="cov1" title="3">batcher := &amp;batcher{
                pendingIds:                make(chan pdata.TraceID, batchChannelSize),
                batches:                   batches,
                currentBatch:              make(Batch, 0, newBatchesInitialCapacity),
                newBatchesInitialCapacity: newBatchesInitialCapacity,
                stopchan:                  make(chan bool),
        }

        // Single goroutine that keeps filling the current batch, contention is expected only
        // when the current batch is being switched.
        go func() </span><span class="cov1" title="3">{
                for id := range batcher.pendingIds </span><span class="cov10" title="20000">{
                        batcher.cbMutex.Lock()
                        batcher.currentBatch = append(batcher.currentBatch, id)
                        batcher.cbMutex.Unlock()
                }</span>
                <span class="cov1" title="3">batcher.stopchan &lt;- true</span>
        }()

        <span class="cov1" title="3">return batcher, nil</span>
}

func (b *batcher) AddToCurrentBatch(id pdata.TraceID) <span class="cov10" title="20000">{
        b.pendingIds &lt;- id
}</span>

func (b *batcher) CloseCurrentAndTakeFirstBatch() (Batch, bool) <span class="cov3" title="17">{
        if readBatch, ok := &lt;-b.batches; ok </span><span class="cov3" title="15">{
                if !b.stopped </span><span class="cov2" title="4">{
                        nextBatch := make(Batch, 0, b.newBatchesInitialCapacity)
                        b.cbMutex.Lock()
                        b.batches &lt;- b.currentBatch
                        b.currentBatch = nextBatch
                        b.cbMutex.Unlock()
                }</span>
                <span class="cov3" title="15">return readBatch, true</span>
        }

        <span class="cov1" title="2">readBatch := b.currentBatch
        b.currentBatch = nil
        return readBatch, false</span>
}

func (b *batcher) Stop() <span class="cov1" title="3">{
        close(b.pendingIds)
        b.stopped = &lt;-b.stopchan
        close(b.batches)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright The OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cascadingfilterprocessor

import (
        "go.opencensus.io/stats"
        "go.opencensus.io/stats/view"
        "go.opencensus.io/tag"
        "go.opentelemetry.io/collector/config/configtelemetry"
        "go.opentelemetry.io/collector/obsreport"
)

// Variables related to metrics specific to Cascading Filter.
var (
        statusSampled              = "Sampled"
        statusNotSampled           = "NotSampled"
        statusExceededKey          = "RateExceeded"
        statusSecondChance         = "SecondChance"
        statusSecondChanceSampled  = "SecondChanceSampled"
        statusSecondChanceExceeded = "SecondChanceRateExceeded"

        tagPolicyKey, _                  = tag.NewKey("policy")
        tagCascadingFilterDecisionKey, _ = tag.NewKey("cascading_filter_decision")
        tagPolicyDecisionKey, _          = tag.NewKey("policy_decision")

        statDecisionLatencyMicroSec  = stats.Int64("policy_decision_latency", "Latency (in microseconds) of a given filtering policy", "µs")
        statOverallDecisionLatencyus = stats.Int64("cascading_filtering_batch_processing_latency", "Latency (in microseconds) of each run of the cascading filter timer", "µs")

        statTraceRemovalAgeSec           = stats.Int64("cascading_trace_removal_age", "Time (in seconds) from arrival of a new trace until its removal from memory", "s")
        statLateSpanArrivalAfterDecision = stats.Int64("cascadind_late_span_age", "Time (in seconds) from the cascading filter decision was taken and the arrival of a late span", "s")

        statPolicyEvaluationErrorCount = stats.Int64("cascading_policy_evaluation_error", "Count of cascading policy evaluation errors", stats.UnitDimensionless)

        statCascadingFilterDecision = stats.Int64("count_final_decision", "Count of traces that were filtered or not", stats.UnitDimensionless)
        statPolicyDecision          = stats.Int64("count_policy_decision", "Count of provisional (policy) decisions if traces were filtered or not", stats.UnitDimensionless)

        statDroppedTooEarlyCount    = stats.Int64("casdading_trace_dropped_too_early", "Count of traces that needed to be dropped the configured wait time", stats.UnitDimensionless)
        statNewTraceIDReceivedCount = stats.Int64("cascading_new_trace_id_received", "Counts the arrival of new traces", stats.UnitDimensionless)
        statTracesOnMemoryGauge     = stats.Int64("cascading_traces_on_memory", "Tracks the number of traces current on memory", stats.UnitDimensionless)
)

// CascadingFilterMetricViews return the metrics views according to given telemetry level.
func CascadingFilterMetricViews(level configtelemetry.Level) []*view.View <span class="cov10" title="2">{
        if level == configtelemetry.LevelNone </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov10" title="2">latencyDistributionAggregation := view.Distribution(1, 2, 5, 10, 25, 50, 75, 100, 150, 200, 300, 400, 500, 750, 1000, 2000, 3000, 4000, 5000, 10000, 20000, 30000, 50000)
        ageDistributionAggregation := view.Distribution(1, 2, 5, 10, 20, 30, 40, 50, 60, 90, 120, 180, 300, 600, 1800, 3600, 7200)

        overallDecisionLatencyView := &amp;view.View{
                Name:        statOverallDecisionLatencyus.Name(),
                Measure:     statOverallDecisionLatencyus,
                Description: statOverallDecisionLatencyus.Description(),
                Aggregation: latencyDistributionAggregation,
        }

        traceRemovalAgeView := &amp;view.View{
                Name:        statTraceRemovalAgeSec.Name(),
                Measure:     statTraceRemovalAgeSec,
                Description: statTraceRemovalAgeSec.Description(),
                Aggregation: ageDistributionAggregation,
        }

        lateSpanArrivalView := &amp;view.View{
                Name:        statLateSpanArrivalAfterDecision.Name(),
                Measure:     statLateSpanArrivalAfterDecision,
                Description: statLateSpanArrivalAfterDecision.Description(),
                Aggregation: ageDistributionAggregation,
        }

        countPolicyEvaluationErrorView := &amp;view.View{
                Name:        statPolicyEvaluationErrorCount.Name(),
                Measure:     statPolicyEvaluationErrorCount,
                Description: statPolicyEvaluationErrorCount.Description(),
                Aggregation: view.Sum(),
        }

        countFinalDecisionView := &amp;view.View{
                Name:        statCascadingFilterDecision.Name(),
                Measure:     statCascadingFilterDecision,
                Description: statCascadingFilterDecision.Description(),
                TagKeys:     []tag.Key{tagPolicyKey, tagCascadingFilterDecisionKey},
                Aggregation: view.Sum(),
        }

        countPolicyDecisionsView := &amp;view.View{
                Name:        statPolicyDecision.Name(),
                Measure:     statPolicyDecision,
                Description: statPolicyDecision.Description(),
                TagKeys:     []tag.Key{tagPolicyKey, tagPolicyDecisionKey},
                Aggregation: view.Sum(),
        }

        policyLatencyView := &amp;view.View{
                Name:        statDecisionLatencyMicroSec.Name(),
                Measure:     statDecisionLatencyMicroSec,
                Description: statDecisionLatencyMicroSec.Description(),
                TagKeys:     []tag.Key{tagPolicyKey},
                Aggregation: view.Sum(),
        }

        countTraceDroppedTooEarlyView := &amp;view.View{
                Name:        statDroppedTooEarlyCount.Name(),
                Measure:     statDroppedTooEarlyCount,
                Description: statDroppedTooEarlyCount.Description(),
                Aggregation: view.Sum(),
        }
        countTraceIDArrivalView := &amp;view.View{
                Name:        statNewTraceIDReceivedCount.Name(),
                Measure:     statNewTraceIDReceivedCount,
                Description: statNewTraceIDReceivedCount.Description(),
                Aggregation: view.Sum(),
        }
        trackTracesOnMemorylView := &amp;view.View{
                Name:        statTracesOnMemoryGauge.Name(),
                Measure:     statTracesOnMemoryGauge,
                Description: statTracesOnMemoryGauge.Description(),
                Aggregation: view.LastValue(),
        }

        legacyViews := []*view.View{
                overallDecisionLatencyView,
                traceRemovalAgeView,
                lateSpanArrivalView,

                countPolicyDecisionsView,
                policyLatencyView,
                countFinalDecisionView,

                countPolicyEvaluationErrorView,
                countTraceDroppedTooEarlyView,
                countTraceIDArrivalView,
                trackTracesOnMemorylView,
        }

        return obsreport.ProcessorMetricViews(typeStr, legacyViews)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright The OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cascadingfilterprocessor

import (
        "context"
        "runtime"
        "sync"
        "sync/atomic"
        "time"

        "go.opencensus.io/stats"
        "go.opencensus.io/tag"
        "go.opentelemetry.io/collector/component"
        "go.opentelemetry.io/collector/component/componenterror"
        "go.opentelemetry.io/collector/consumer"
        "go.opentelemetry.io/collector/consumer/pdata"
        "go.opentelemetry.io/collector/translator/conventions"
        "go.uber.org/zap"

        "github.com/open-telemetry/opentelemetry-collector-contrib/processor/cascadingfilterprocessor/config"
        "github.com/open-telemetry/opentelemetry-collector-contrib/processor/cascadingfilterprocessor/idbatcher"
        "github.com/open-telemetry/opentelemetry-collector-contrib/processor/cascadingfilterprocessor/sampling"
)

// Policy combines a sampling policy evaluator with the destinations to be
// used for that policy.
type Policy struct {
        // Name used to identify this policy instance.
        Name string
        // Evaluator that decides if a trace is sampled or not by this policy instance.
        Evaluator sampling.PolicyEvaluator
        // ctx used to carry metric tags of each policy.
        ctx context.Context
        // probabilisticFilter determines whether `sampling.probability` field must be calculated and added
        probabilisticFilter bool
}

// traceKey is defined since sync.Map requires a comparable type, isolating it on its own
// type to help track usage.
type traceKey [16]byte

// cascadingFilterSpanProcessor handles the incoming trace data and uses the given sampling
// policy to sample traces.
type cascadingFilterSpanProcessor struct {
        ctx             context.Context
        nextConsumer    consumer.Traces
        start           sync.Once
        maxNumTraces    uint64
        policies        []*Policy
        logger          *zap.Logger
        idToTrace       sync.Map
        policyTicker    tTicker
        decisionBatcher idbatcher.Batcher
        deleteChan      chan traceKey
        numTracesOnMap  uint64

        currentSecond        int64
        maxSpansPerSecond    int64
        spansInCurrentSecond int64
}

const (
        probabilisticFilterPolicyName = "probabilistic_filter"
        probabilisticRuleVale         = "probabilistic"
        filteredRuleValue             = "filtered"
        AttributeSamplingRule         = "sampling.rule"
)

// newTraceProcessor returns a processor.TraceProcessor that will perform Cascading Filter according to the given
// configuration.
func newTraceProcessor(logger *zap.Logger, nextConsumer consumer.Traces, cfg config.Config) (component.TracesProcessor, error) <span class="cov2" title="5">{
        if nextConsumer == nil </span><span class="cov0" title="0">{
                return nil, componenterror.ErrNilNextConsumer
        }</span>

        <span class="cov2" title="5">return newCascadingFilterSpanProcessor(logger, nextConsumer, cfg)</span>
}

func newCascadingFilterSpanProcessor(logger *zap.Logger, nextConsumer consumer.Traces, cfg config.Config) (*cascadingFilterSpanProcessor, error) <span class="cov2" title="8">{
        numDecisionBatches := uint64(cfg.DecisionWait.Seconds())
        inBatcher, err := idbatcher.New(numDecisionBatches, cfg.ExpectedNewTracesPerSec, uint64(2*runtime.NumCPU()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="8">ctx := context.Background()
        var policies []*Policy

        // This must be always first as it must select traces independently of other policies
        if cfg.ProbabilisticFilteringRatio != nil &amp;&amp; *cfg.ProbabilisticFilteringRatio &gt; 0.0 </span><span class="cov1" title="2">{
                policyCtx, err := tag.New(ctx, tag.Upsert(tagPolicyKey, probabilisticFilterPolicyName))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="2">eval, err := getProbabilisticFilterEvaluator(logger, int64(float32(cfg.SpansPerSecond)**cfg.ProbabilisticFilteringRatio))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="2">policy := &amp;Policy{
                        Name:                probabilisticFilterPolicyName,
                        Evaluator:           eval,
                        ctx:                 policyCtx,
                        probabilisticFilter: true,
                }
                policies = append(policies, policy)</span>
        }

        <span class="cov2" title="8">for i := range cfg.PolicyCfgs </span><span class="cov2" title="11">{
                policyCfg := &amp;cfg.PolicyCfgs[i]
                policyCtx, err := tag.New(ctx, tag.Upsert(tagPolicyKey, policyCfg.Name))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov2" title="11">eval, err := getPolicyEvaluator(logger, policyCfg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov2" title="11">policy := &amp;Policy{
                        Name:                policyCfg.Name,
                        Evaluator:           eval,
                        ctx:                 policyCtx,
                        probabilisticFilter: false,
                }
                policies = append(policies, policy)</span>
        }

        <span class="cov2" title="8">cfsp := &amp;cascadingFilterSpanProcessor{
                ctx:               ctx,
                nextConsumer:      nextConsumer,
                maxNumTraces:      cfg.NumTraces,
                maxSpansPerSecond: cfg.SpansPerSecond,
                logger:            logger,
                decisionBatcher:   inBatcher,
                policies:          policies,
        }

        cfsp.policyTicker = &amp;policyTicker{onTick: cfsp.samplingPolicyOnTick}
        cfsp.deleteChan = make(chan traceKey, cfg.NumTraces)

        return cfsp, nil</span>
}

func getPolicyEvaluator(logger *zap.Logger, cfg *config.PolicyCfg) (sampling.PolicyEvaluator, error) <span class="cov2" title="11">{
        return sampling.NewFilter(logger, cfg)
}</span>

func getProbabilisticFilterEvaluator(logger *zap.Logger, maxSpanRate int64) (sampling.PolicyEvaluator, error) <span class="cov1" title="2">{
        return sampling.NewProbabilisticFilter(logger, maxSpanRate)
}</span>

type policyMetrics struct {
        idNotFoundOnMapCount, evaluateErrorCount, decisionSampled, decisionNotSampled int64
}

func (cfsp *cascadingFilterSpanProcessor) updateRate(currSecond int64, numSpans int64) sampling.Decision <span class="cov2" title="11">{
        if cfsp.currentSecond != currSecond </span><span class="cov1" title="3">{
                cfsp.currentSecond = currSecond
                cfsp.spansInCurrentSecond = 0
        }</span>

        <span class="cov2" title="11">spansInSecondIfSampled := cfsp.spansInCurrentSecond + numSpans
        if spansInSecondIfSampled &lt;= cfsp.maxSpansPerSecond </span><span class="cov2" title="11">{
                cfsp.spansInCurrentSecond = spansInSecondIfSampled
                return sampling.Sampled
        }</span>

        <span class="cov0" title="0">return sampling.NotSampled</span>
}

func (cfsp *cascadingFilterSpanProcessor) samplingPolicyOnTick() <span class="cov3" title="23">{
        metrics := policyMetrics{}

        startTime := time.Now()
        batch, _ := cfsp.decisionBatcher.CloseCurrentAndTakeFirstBatch()
        batchLen := len(batch)
        cfsp.logger.Debug("Sampling Policy Evaluation ticked")

        currSecond := time.Now().Unix()

        totalSpans := int64(0)
        selectedByProbabilisticFilterSpans := int64(0)

        // The first run applies decisions to batches, executing each policy separately
        for _, id := range batch </span><span class="cov3" title="17">{
                d, ok := cfsp.idToTrace.Load(traceKey(id.Bytes()))
                if !ok </span><span class="cov0" title="0">{
                        metrics.idNotFoundOnMapCount++
                        continue</span>
                }
                <span class="cov3" title="17">trace := d.(*sampling.TraceData)
                trace.DecisionTime = time.Now()
                totalSpans += trace.SpanCount

                provisionalDecision, _ := cfsp.makeProvisionalDecision(id, trace)
                if provisionalDecision == sampling.Sampled </span><span class="cov2" title="11">{
                        trace.FinalDecision = cfsp.updateRate(currSecond, trace.SpanCount)
                        if trace.FinalDecision == sampling.Sampled </span><span class="cov2" title="11">{
                                if trace.SelectedByProbabilisticFilter </span><span class="cov0" title="0">{
                                        selectedByProbabilisticFilterSpans += trace.SpanCount
                                }</span>
                                <span class="cov2" title="11">_ = stats.RecordWithTags(
                                        cfsp.ctx,
                                        []tag.Mutator{tag.Insert(tagCascadingFilterDecisionKey, statusSampled)},
                                        statCascadingFilterDecision.M(int64(1)),
                                )</span>
                        } else<span class="cov0" title="0"> {
                                _ = stats.RecordWithTags(
                                        cfsp.ctx,
                                        []tag.Mutator{tag.Insert(tagCascadingFilterDecisionKey, statusExceededKey)},
                                        statCascadingFilterDecision.M(int64(1)),
                                )
                        }</span>
                } else<span class="cov2" title="6"> if provisionalDecision == sampling.SecondChance </span><span class="cov0" title="0">{
                        trace.FinalDecision = sampling.SecondChance
                }</span> else<span class="cov2" title="6"> {
                        trace.FinalDecision = provisionalDecision
                        _ = stats.RecordWithTags(
                                cfsp.ctx,
                                []tag.Mutator{tag.Insert(tagCascadingFilterDecisionKey, statusNotSampled)},
                                statCascadingFilterDecision.M(int64(1)),
                        )
                }</span>
        }

        // The second run executes the decisions and makes "SecondChance" decisions in the meantime
        <span class="cov3" title="23">for _, id := range batch </span><span class="cov3" title="17">{
                d, ok := cfsp.idToTrace.Load(traceKey(id.Bytes()))
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov3" title="17">trace := d.(*sampling.TraceData)
                if trace.FinalDecision == sampling.SecondChance </span><span class="cov0" title="0">{
                        trace.FinalDecision = cfsp.updateRate(currSecond, trace.SpanCount)
                        if trace.FinalDecision == sampling.Sampled </span><span class="cov0" title="0">{
                                _ = stats.RecordWithTags(
                                        cfsp.ctx,
                                        []tag.Mutator{tag.Insert(tagCascadingFilterDecisionKey, statusSecondChanceSampled)},
                                        statCascadingFilterDecision.M(int64(1)),
                                )
                        }</span> else<span class="cov0" title="0"> {
                                _ = stats.RecordWithTags(
                                        cfsp.ctx,
                                        []tag.Mutator{tag.Insert(tagCascadingFilterDecisionKey, statusSecondChanceExceeded)},
                                        statCascadingFilterDecision.M(int64(1)),
                                )
                        }</span>
                }

                // Sampled or not, remove the batches
                <span class="cov3" title="17">trace.Lock()
                traceBatches := trace.ReceivedBatches
                trace.ReceivedBatches = nil
                trace.Unlock()

                if trace.FinalDecision == sampling.Sampled </span><span class="cov2" title="11">{
                        metrics.decisionSampled++

                        // Combine all individual batches into a single batch so
                        // consumers may operate on the entire trace
                        allSpans := pdata.NewTraces()
                        for j := 0; j &lt; len(traceBatches); j++ </span><span class="cov3" title="26">{
                                batch := traceBatches[j]
                                batch.ResourceSpans().MoveAndAppendTo(allSpans.ResourceSpans())
                        }</span>

                        <span class="cov2" title="11">if trace.SelectedByProbabilisticFilter </span><span class="cov0" title="0">{
                                updateProbabilisticRateTag(allSpans, selectedByProbabilisticFilterSpans, totalSpans)
                        }</span> else<span class="cov2" title="11"> {
                                updateFilteringTag(allSpans)
                        }</span>

                        <span class="cov2" title="11">_ = cfsp.nextConsumer.ConsumeTraces(cfsp.ctx, allSpans)</span>
                } else<span class="cov2" title="6"> {
                        metrics.decisionNotSampled++
                }</span>
        }

        <span class="cov3" title="23">stats.Record(cfsp.ctx,
                statOverallDecisionLatencyus.M(int64(time.Since(startTime)/time.Microsecond)),
                statDroppedTooEarlyCount.M(metrics.idNotFoundOnMapCount),
                statPolicyEvaluationErrorCount.M(metrics.evaluateErrorCount),
                statTracesOnMemoryGauge.M(int64(atomic.LoadUint64(&amp;cfsp.numTracesOnMap))))

        cfsp.logger.Debug("Sampling policy evaluation completed",
                zap.Int("batch.len", batchLen),
                zap.Int64("sampled", metrics.decisionSampled),
                zap.Int64("notSampled", metrics.decisionNotSampled),
                zap.Int64("droppedPriorToEvaluation", metrics.idNotFoundOnMapCount),
                zap.Int64("policyEvaluationErrors", metrics.evaluateErrorCount),
        )</span>
}

func updateProbabilisticRateTag(traces pdata.Traces, probabilisticSpans int64, allSpans int64) <span class="cov0" title="0">{
        ratio := float64(probabilisticSpans) / float64(allSpans)

        rs := traces.ResourceSpans()

        for i := 0; i &lt; rs.Len(); i++ </span><span class="cov0" title="0">{
                ils := rs.At(i).InstrumentationLibrarySpans()
                for j := 0; j &lt; ils.Len(); j++ </span><span class="cov0" title="0">{
                        spans := ils.At(j).Spans()
                        for k := 0; k &lt; spans.Len(); k++ </span><span class="cov0" title="0">{
                                attrs := spans.At(k).Attributes()
                                av, found := attrs.Get(conventions.AttributeSamplingProbability)
                                if found &amp;&amp; av.Type() == pdata.AttributeValueDOUBLE </span><span class="cov0" title="0">{
                                        av.SetDoubleVal(av.DoubleVal() * ratio)
                                }</span> else<span class="cov0" title="0"> {
                                        attrs.UpsertDouble(conventions.AttributeSamplingProbability, ratio)
                                }</span>
                                <span class="cov0" title="0">attrs.UpsertString(AttributeSamplingRule, probabilisticRuleVale)</span>
                        }
                }
        }
}

func updateFilteringTag(traces pdata.Traces) <span class="cov2" title="11">{
        rs := traces.ResourceSpans()

        for i := 0; i &lt; rs.Len(); i++ </span><span class="cov3" title="26">{
                ils := rs.At(i).InstrumentationLibrarySpans()
                for j := 0; j &lt; ils.Len(); j++ </span><span class="cov3" title="26">{
                        spans := ils.At(j).Spans()
                        for k := 0; k &lt; spans.Len(); k++ </span><span class="cov3" title="26">{
                                attrs := spans.At(k).Attributes()
                                attrs.UpsertString(AttributeSamplingRule, filteredRuleValue)
                        }</span>
                }
        }
}

func (cfsp *cascadingFilterSpanProcessor) makeProvisionalDecision(id pdata.TraceID, trace *sampling.TraceData) (sampling.Decision, *Policy) <span class="cov3" title="23">{
        provisionalDecision := sampling.Unspecified
        var matchingPolicy *Policy = nil

        for i, policy := range cfsp.policies </span><span class="cov3" title="35">{
                policyEvaluateStartTime := time.Now()
                decision := policy.Evaluator.Evaluate(id, trace)
                stats.Record(
                        policy.ctx,
                        statDecisionLatencyMicroSec.M(int64(time.Since(policyEvaluateStartTime)/time.Microsecond)))

                trace.Decisions[i] = decision

                switch decision </span>{
                case sampling.Sampled:<span class="cov3" title="18">
                        // any single policy that decides to sample will cause the decision to be sampled
                        // the nextConsumer will get the context from the first matching policy
                        provisionalDecision = sampling.Sampled
                        if matchingPolicy == nil </span><span class="cov3" title="13">{
                                matchingPolicy = policy
                        }</span>

                        <span class="cov3" title="18">if policy.probabilisticFilter </span><span class="cov1" title="1">{
                                trace.SelectedByProbabilisticFilter = true
                        }</span>

                        <span class="cov3" title="18">_ = stats.RecordWithTags(
                                policy.ctx,
                                []tag.Mutator{tag.Insert(tagPolicyDecisionKey, statusSampled)},
                                statPolicyDecision.M(int64(1)),
                        )</span>
                case sampling.NotSampled:<span class="cov2" title="9">
                        if provisionalDecision == sampling.Unspecified </span><span class="cov2" title="8">{
                                provisionalDecision = sampling.NotSampled
                        }</span>
                        <span class="cov2" title="9">_ = stats.RecordWithTags(
                                policy.ctx,
                                []tag.Mutator{tag.Insert(tagPolicyDecisionKey, statusNotSampled)},
                                statPolicyDecision.M(int64(1)),
                        )</span>
                case sampling.SecondChance:<span class="cov2" title="6">
                        if provisionalDecision != sampling.Sampled </span><span class="cov2" title="4">{
                                provisionalDecision = sampling.SecondChance
                        }</span>

                        <span class="cov2" title="6">_ = stats.RecordWithTags(
                                policy.ctx,
                                []tag.Mutator{tag.Insert(tagPolicyDecisionKey, statusSecondChance)},
                                statPolicyDecision.M(int64(1)),
                        )</span>
                }
        }

        <span class="cov3" title="23">return provisionalDecision, matchingPolicy</span>
}

// ConsumeTraceData is required by the SpanProcessor interface.
func (cfsp *cascadingFilterSpanProcessor) ConsumeTraces(ctx context.Context, td pdata.Traces) error <span class="cov9" title="69238">{
        cfsp.start.Do(func() </span><span class="cov2" title="8">{
                cfsp.logger.Info("First trace data arrived, starting cascading_filter timers")
                cfsp.policyTicker.Start(1 * time.Second)
        }</span>)
        <span class="cov9" title="69238">resourceSpans := td.ResourceSpans()
        for i := 0; i &lt; resourceSpans.Len(); i++ </span><span class="cov9" title="69238">{
                resourceSpan := resourceSpans.At(i)
                cfsp.processTraces(resourceSpan)
        }</span>
        <span class="cov9" title="69238">return nil</span>
}

func (cfsp *cascadingFilterSpanProcessor) groupSpansByTraceKey(resourceSpans pdata.ResourceSpans) map[traceKey][]*pdata.Span <span class="cov9" title="69238">{
        idToSpans := make(map[traceKey][]*pdata.Span)
        ilss := resourceSpans.InstrumentationLibrarySpans()
        for j := 0; j &lt; ilss.Len(); j++ </span><span class="cov9" title="69238">{
                ils := ilss.At(j)
                spansLen := ils.Spans().Len()
                for k := 0; k &lt; spansLen; k++ </span><span class="cov9" title="69238">{
                        span := ils.Spans().At(k)
                        tk := traceKey(span.TraceID().Bytes())
                        if len(tk) != 16 </span><span class="cov0" title="0">{
                                cfsp.logger.Warn("Span without valid TraceId")
                        }</span>
                        <span class="cov9" title="69238">idToSpans[tk] = append(idToSpans[tk], &amp;span)</span>
                }
        }
        <span class="cov9" title="69238">return idToSpans</span>
}

func (cfsp *cascadingFilterSpanProcessor) processTraces(resourceSpans pdata.ResourceSpans) <span class="cov9" title="69238">{
        // Group spans per their traceId to minimize contention on idToTrace
        idToSpans := cfsp.groupSpansByTraceKey(resourceSpans)
        var newTraceIDs int64
        for id, spans := range idToSpans </span><span class="cov9" title="69238">{
                lenSpans := int64(len(spans))
                lenPolicies := len(cfsp.policies)
                initialDecisions := make([]sampling.Decision, lenPolicies)
                for i := 0; i &lt; lenPolicies; i++ </span><span class="cov10" title="69289">{
                        initialDecisions[i] = sampling.Pending
                }</span>
                <span class="cov9" title="69238">initialTraceData := &amp;sampling.TraceData{
                        Decisions:   initialDecisions,
                        ArrivalTime: time.Now(),
                        SpanCount:   lenSpans,
                }
                d, loaded := cfsp.idToTrace.LoadOrStore(id, initialTraceData)

                actualData := d.(*sampling.TraceData)
                if loaded </span><span class="cov9" title="68529">{
                        // PMM: why actualData is not updated with new trace?
                        atomic.AddInt64(&amp;actualData.SpanCount, lenSpans)
                }</span> else<span class="cov6" title="709"> {
                        newTraceIDs++
                        cfsp.decisionBatcher.AddToCurrentBatch(pdata.NewTraceID(id))
                        atomic.AddUint64(&amp;cfsp.numTracesOnMap, 1)
                        postDeletion := false
                        currTime := time.Now()

                        for !postDeletion </span><span class="cov6" title="929">{
                                select </span>{
                                case cfsp.deleteChan &lt;- id:<span class="cov6" title="709">
                                        postDeletion = true</span>
                                default:<span class="cov5" title="220">
                                        // Note this is a buffered channel, so this will only delete excessive traces (if they exist)
                                        traceKeyToDrop := &lt;-cfsp.deleteChan
                                        cfsp.dropTrace(traceKeyToDrop, currTime)</span>
                                }
                        }
                }

                <span class="cov9" title="69238">for i, policy := range cfsp.policies </span><span class="cov9" title="69238">{
                        var traceTd pdata.Traces
                        actualData.Lock()
                        actualDecision := actualData.Decisions[i]
                        // If decision is pending, we want to add the new spans still under the lock, so the decision doesn't happen
                        // in between the transition from pending.
                        if actualDecision == sampling.Pending </span><span class="cov9" title="69234">{
                                // Add the spans to the trace, but only once for all policy, otherwise same spans will
                                // be duplicated in the final trace.
                                traceTd = prepareTraceBatch(resourceSpans, spans)
                                actualData.ReceivedBatches = append(actualData.ReceivedBatches, traceTd)
                                actualData.Unlock()
                                break</span>
                        }
                        <span class="cov2" title="4">actualData.Unlock()

                        // This section is run in case the decision was already applied earlier
                        switch actualDecision </span>{
                        case sampling.Pending:<span class="cov0" title="0"></span>
                                // All process for pending done above, keep the case so it doesn't go to default.
                        case sampling.SecondChance:<span class="cov0" title="0"></span>
                                // It shouldn't normally get here, keep the case so it doesn't go to default, like above.
                        case sampling.Sampled:<span class="cov1" title="2">
                                // Forward the spans to the policy destinations
                                traceTd := prepareTraceBatch(resourceSpans, spans)
                                if err := cfsp.nextConsumer.ConsumeTraces(policy.ctx, traceTd); err != nil </span><span class="cov0" title="0">{
                                        cfsp.logger.Warn("Error sending late arrived spans to destination",
                                                zap.String("policy", policy.Name),
                                                zap.Error(err))
                                }</span>
                                <span class="cov1" title="2">fallthrough</span> // so OnLateArrivingSpans is also called for decision Sampled.
                        case sampling.NotSampled:<span class="cov2" title="4">
                                policy.Evaluator.OnLateArrivingSpans(actualDecision, spans)
                                stats.Record(cfsp.ctx, statLateSpanArrivalAfterDecision.M(int64(time.Since(actualData.DecisionTime)/time.Second)))</span>

                        default:<span class="cov0" title="0">
                                cfsp.logger.Warn("Encountered unexpected sampling decision",
                                        zap.String("policy", policy.Name),
                                        zap.Int("decision", int(actualDecision)))</span>
                        }

                        // At this point the late arrival has been passed to nextConsumer. Need to break out of the policy loop
                        // so that it isn't sent to nextConsumer more than once when multiple policies chose to sample
                        <span class="cov2" title="4">if actualDecision == sampling.Sampled </span><span class="cov1" title="2">{
                                break</span>
                        }
                }
        }

        <span class="cov9" title="69238">stats.Record(cfsp.ctx, statNewTraceIDReceivedCount.M(newTraceIDs))</span>
}

func (cfsp *cascadingFilterSpanProcessor) GetCapabilities() component.ProcessorCapabilities <span class="cov0" title="0">{
        return component.ProcessorCapabilities{MutatesConsumedData: false}
}</span>

// Start is invoked during service startup.
func (cfsp *cascadingFilterSpanProcessor) Start(context.Context, component.Host) error <span class="cov0" title="0">{
        return nil
}</span>

// Shutdown is invoked during service shutdown.
func (cfsp *cascadingFilterSpanProcessor) Shutdown(context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

func (cfsp *cascadingFilterSpanProcessor) dropTrace(traceID traceKey, deletionTime time.Time) <span class="cov5" title="220">{
        var trace *sampling.TraceData
        if d, ok := cfsp.idToTrace.Load(traceID); ok </span><span class="cov5" title="220">{
                trace = d.(*sampling.TraceData)
                cfsp.idToTrace.Delete(traceID)
                // Subtract one from numTracesOnMap per https://godoc.org/sync/atomic#AddUint64
                atomic.AddUint64(&amp;cfsp.numTracesOnMap, ^uint64(0))
        }</span>
        <span class="cov5" title="220">if trace == nil </span><span class="cov0" title="0">{
                cfsp.logger.Error("Attempt to delete traceID not on table")
                return
        }</span>

        <span class="cov5" title="220">stats.Record(cfsp.ctx, statTraceRemovalAgeSec.M(int64(deletionTime.Sub(trace.ArrivalTime)/time.Second)))</span>
}

func prepareTraceBatch(rss pdata.ResourceSpans, spans []*pdata.Span) pdata.Traces <span class="cov9" title="69236">{
        traceTd := pdata.NewTraces()
        traceTd.ResourceSpans().Resize(1)
        rs := traceTd.ResourceSpans().At(0)
        rss.Resource().CopyTo(rs.Resource())
        rs.InstrumentationLibrarySpans().Resize(1)
        ils := rs.InstrumentationLibrarySpans().At(0)
        for _, span := range spans </span><span class="cov9" title="69236">{
                ils.Spans().Append(*span)
        }</span>
        <span class="cov9" title="69236">return traceTd</span>
}

// tTicker interface allows easier testing of ticker related functionality used by cascadingfilterprocessor
type tTicker interface {
        // Start sets the frequency of the ticker and starts the periodic calls to OnTick.
        Start(d time.Duration)
        // OnTick is called when the ticker fires.
        OnTick()
        // Stops firing the ticker.
        Stop()
}

type policyTicker struct {
        ticker *time.Ticker
        onTick func()
}

func (pt *policyTicker) Start(d time.Duration) <span class="cov2" title="4">{
        pt.ticker = time.NewTicker(d)
        go func() </span><span class="cov2" title="4">{
                for range pt.ticker.C </span><span class="cov1" title="2">{
                        pt.OnTick()
                }</span>
        }()
}
func (pt *policyTicker) OnTick() <span class="cov1" title="2">{
        pt.onTick()
}</span>
func (pt *policyTicker) Stop() <span class="cov0" title="0">{
        pt.ticker.Stop()
}</span>

var _ tTicker = (*policyTicker)(nil)
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright The OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package sampling

import (
        "errors"
        "regexp"
        "time"

        "go.uber.org/zap"

        "github.com/open-telemetry/opentelemetry-collector-contrib/processor/cascadingfilterprocessor/config"
)

type numericAttributeFilter struct {
        key                string
        minValue, maxValue int64
}

type stringAttributeFilter struct {
        key    string
        values map[string]struct{}
}

type policyEvaluator struct {
        numericAttr *numericAttributeFilter
        stringAttr  *stringAttributeFilter

        operationRe      *regexp.Regexp
        minDuration      *time.Duration
        minNumberOfSpans *int

        currentSecond        int64
        maxSpansPerSecond    int64
        spansInCurrentSecond int64

        invertMatch bool

        logger *zap.Logger
}

var _ PolicyEvaluator = (*policyEvaluator)(nil)

func createNumericAttributeFilter(cfg *config.NumericAttributeCfg) *numericAttributeFilter <span class="cov0" title="0">{
        if cfg == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;numericAttributeFilter{
                key:      cfg.Key,
                minValue: cfg.MinValue,
                maxValue: cfg.MaxValue,
        }</span>
}

func createStringAttributeFilter(cfg *config.StringAttributeCfg) *stringAttributeFilter <span class="cov0" title="0">{
        if cfg == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">valuesMap := make(map[string]struct{})
        for _, value := range cfg.Values </span><span class="cov0" title="0">{
                if value != "" </span><span class="cov0" title="0">{
                        valuesMap[value] = struct{}{}
                }</span>
        }

        <span class="cov0" title="0">return &amp;stringAttributeFilter{
                key:    cfg.Key,
                values: valuesMap,
        }</span>
}

// NewProbabilisticFilter creates a policy evaluator intended for selecting samples probabilistically
func NewProbabilisticFilter(logger *zap.Logger, maxSpanRate int64) (PolicyEvaluator, error) <span class="cov0" title="0">{
        return &amp;policyEvaluator{
                logger:               logger,
                currentSecond:        0,
                spansInCurrentSecond: 0,
                maxSpansPerSecond:    maxSpanRate,
        }, nil
}</span>

// NewFilter creates a policy evaluator that samples all traces with the specified criteria
func NewFilter(logger *zap.Logger, cfg *config.PolicyCfg) (PolicyEvaluator, error) <span class="cov0" title="0">{
        numericAttrFilter := createNumericAttributeFilter(cfg.NumericAttributeCfg)
        stringAttrFilter := createStringAttributeFilter(cfg.StringAttributeCfg)

        var operationRe *regexp.Regexp
        var err error

        if cfg.PropertiesCfg.NamePattern != nil </span><span class="cov0" title="0">{
                operationRe, err = regexp.Compile(*cfg.PropertiesCfg.NamePattern)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">if cfg.PropertiesCfg.MinDuration != nil &amp;&amp; *cfg.PropertiesCfg.MinDuration &lt; 0*time.Second </span><span class="cov0" title="0">{
                return nil, errors.New("minimum span duration must be a non-negative number")
        }</span>

        <span class="cov0" title="0">if cfg.PropertiesCfg.MinNumberOfSpans != nil &amp;&amp; *cfg.PropertiesCfg.MinNumberOfSpans &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("minimum number of spans must be a positive number")
        }</span>

        <span class="cov0" title="0">return &amp;policyEvaluator{
                stringAttr:           stringAttrFilter,
                numericAttr:          numericAttrFilter,
                operationRe:          operationRe,
                minDuration:          cfg.PropertiesCfg.MinDuration,
                minNumberOfSpans:     cfg.PropertiesCfg.MinNumberOfSpans,
                logger:               logger,
                currentSecond:        0,
                spansInCurrentSecond: 0,
                maxSpansPerSecond:    cfg.SpansPerSecond,
                invertMatch:          cfg.InvertMatch,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright The OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package sampling

import (
        "time"

        "go.opentelemetry.io/collector/consumer/pdata"
)

// OnLateArrivingSpans notifies the evaluator that the given list of spans arrived
// after the sampling decision was already taken for the trace.
// This gives the evaluator a chance to log any message/metrics and/or update any
// related internal state.
func (pe *policyEvaluator) OnLateArrivingSpans(earlyDecision Decision, spans []*pdata.Span) error <span class="cov2" title="4">{
        return nil
}</span>

func tsToMicros(ts pdata.Timestamp) int64 <span class="cov10" title="1608">{
        return int64(ts / 1000)
}</span>

func checkIfNumericAttrFound(attrs pdata.AttributeMap, filter *numericAttributeFilter) bool <span class="cov3" title="10">{
        if v, ok := attrs.Get(filter.key); ok </span><span class="cov2" title="4">{
                value := v.IntVal()
                if value &gt;= filter.minValue &amp;&amp; value &lt;= filter.maxValue </span><span class="cov1" title="2">{
                        return true
                }</span>
        }
        <span class="cov3" title="8">return false</span>
}

func checkIfStringAttrFound(attrs pdata.AttributeMap, filter *stringAttributeFilter) bool <span class="cov3" title="11">{
        if v, ok := attrs.Get(filter.key); ok </span><span class="cov2" title="4">{
                truncableStr := v.StringVal()
                if len(truncableStr) &gt; 0 </span><span class="cov2" title="4">{
                        if _, ok := filter.values[truncableStr]; ok </span><span class="cov1" title="2">{
                                return true
                        }</span>
                }
        }
        <span class="cov3" title="9">return false</span>
}

// evaluateRules goes through the defined properties and checks if they are matched
func (pe *policyEvaluator) evaluateRules(_ pdata.TraceID, trace *TraceData) Decision <span class="cov5" title="34">{
        trace.Lock()
        batches := trace.ReceivedBatches
        trace.Unlock()

        matchingOperationFound := false
        matchingStringAttrFound := false
        matchingNumericAttrFound := false
        spanCount := 0
        minStartTime := int64(0)
        maxEndTime := int64(0)

        for _, batch := range batches </span><span class="cov5" title="34">{
                rs := batch.ResourceSpans()

                for i := 0; i &lt; rs.Len(); i++ </span><span class="cov5" title="34">{
                        if pe.stringAttr != nil || pe.numericAttr != nil </span><span class="cov3" title="11">{
                                res := rs.At(i).Resource()
                                if !matchingStringAttrFound &amp;&amp; pe.stringAttr != nil </span><span class="cov3" title="6">{
                                        matchingStringAttrFound = checkIfStringAttrFound(res.Attributes(), pe.stringAttr)
                                }</span>
                                <span class="cov3" title="11">if !matchingNumericAttrFound &amp;&amp; pe.numericAttr != nil </span><span class="cov2" title="5">{
                                        matchingNumericAttrFound = checkIfNumericAttrFound(res.Attributes(), pe.numericAttr)
                                }</span>
                        }

                        <span class="cov5" title="34">ils := rs.At(i).InstrumentationLibrarySpans()
                        for j := 0; j &lt; ils.Len(); j++ </span><span class="cov5" title="34">{
                                spans := ils.At(j).Spans()
                                spanCount += spans.Len()
                                for k := 0; k &lt; spans.Len(); k++ </span><span class="cov9" title="1222">{
                                        span := spans.At(k)

                                        if pe.stringAttr != nil || pe.numericAttr != nil </span><span class="cov3" title="11">{
                                                if !matchingStringAttrFound &amp;&amp; pe.stringAttr != nil </span><span class="cov2" title="5">{
                                                        matchingStringAttrFound = checkIfStringAttrFound(span.Attributes(), pe.stringAttr)
                                                }</span>
                                                <span class="cov3" title="11">if !matchingNumericAttrFound &amp;&amp; pe.numericAttr != nil </span><span class="cov2" title="5">{
                                                        matchingNumericAttrFound = checkIfNumericAttrFound(span.Attributes(), pe.numericAttr)
                                                }</span>
                                        }

                                        <span class="cov9" title="1222">if pe.operationRe != nil &amp;&amp; !matchingOperationFound </span><span class="cov7" title="210">{
                                                if pe.operationRe.MatchString(span.Name()) </span><span class="cov3" title="8">{
                                                        matchingOperationFound = true
                                                }</span>
                                        }

                                        <span class="cov9" title="1222">if pe.minDuration != nil </span><span class="cov9" title="804">{
                                                startTs := tsToMicros(span.StartTimestamp())
                                                endTs := tsToMicros(span.EndTimestamp())

                                                if minStartTime == 0 </span><span class="cov4" title="12">{
                                                        minStartTime = startTs
                                                        maxEndTime = endTs
                                                }</span> else<span class="cov9" title="792"> {
                                                        if startTs &lt; minStartTime </span><span class="cov0" title="0">{
                                                                minStartTime = startTs
                                                        }</span>
                                                        <span class="cov9" title="792">if endTs &gt; maxEndTime </span><span class="cov0" title="0">{
                                                                maxEndTime = endTs
                                                        }</span>
                                                }
                                        }

                                }
                        }
                }
        }

        <span class="cov5" title="34">conditionMet := struct {
                operationName, minDuration, minSpanCount, stringAttr, numericAttr bool
        }{
                operationName: true,
                minDuration:   true,
                minSpanCount:  true,
                stringAttr:    true,
                numericAttr:   true,
        }

        if pe.operationRe != nil </span><span class="cov4" title="12">{
                conditionMet.operationName = matchingOperationFound
        }</span>
        <span class="cov5" title="34">if pe.minNumberOfSpans != nil </span><span class="cov4" title="12">{
                conditionMet.minSpanCount = spanCount &gt;= *pe.minNumberOfSpans
        }</span>
        <span class="cov5" title="34">if pe.minDuration != nil </span><span class="cov4" title="12">{
                conditionMet.minDuration = maxEndTime &gt; minStartTime &amp;&amp; maxEndTime-minStartTime &gt;= pe.minDuration.Microseconds()
        }</span>
        <span class="cov5" title="34">if pe.numericAttr != nil </span><span class="cov2" title="5">{
                conditionMet.numericAttr = matchingNumericAttrFound
        }</span>
        <span class="cov5" title="34">if pe.stringAttr != nil </span><span class="cov3" title="6">{
                conditionMet.stringAttr = matchingStringAttrFound
        }</span>

        <span class="cov5" title="34">if conditionMet.minSpanCount &amp;&amp;
                conditionMet.minDuration &amp;&amp;
                conditionMet.operationName &amp;&amp;
                conditionMet.numericAttr &amp;&amp;
                conditionMet.stringAttr </span><span class="cov4" title="15">{
                if pe.invertMatch </span><span class="cov2" title="4">{
                        return NotSampled
                }</span>
                <span class="cov3" title="11">return Sampled</span>
        }

        <span class="cov4" title="19">if pe.invertMatch </span><span class="cov3" title="6">{
                return Sampled
        }</span>
        <span class="cov4" title="13">return NotSampled</span>
}

func (pe *policyEvaluator) shouldConsider(currSecond int64, trace *TraceData) bool <span class="cov5" title="36">{
        if pe.maxSpansPerSecond &lt; 0 </span><span class="cov0" title="0">{
                // This emits "second chance" traces
                return true
        }</span> else<span class="cov5" title="36"> if trace.SpanCount &gt; pe.maxSpansPerSecond </span><span class="cov1" title="2">{
                // This trace will never fit, there are more spans than max limit
                return false
        }</span> else<span class="cov5" title="34"> if pe.currentSecond == currSecond &amp;&amp; trace.SpanCount &gt; pe.maxSpansPerSecond-pe.spansInCurrentSecond </span><span class="cov0" title="0">{
                // This trace will not fit in this second, no way
                return false
        }</span> else<span class="cov5" title="34"> {
                // This has some chances
                return true
        }</span>
}

func (pe *policyEvaluator) emitsSecondChance() bool <span class="cov4" title="17">{
        return pe.maxSpansPerSecond &lt; 0
}</span>

func (pe *policyEvaluator) updateRate(currSecond int64, numSpans int64) Decision <span class="cov4" title="17">{
        if pe.currentSecond != currSecond </span><span class="cov4" title="14">{
                pe.currentSecond = currSecond
                pe.spansInCurrentSecond = 0
        }</span>

        <span class="cov4" title="17">spansInSecondIfSampled := pe.spansInCurrentSecond + numSpans
        if spansInSecondIfSampled &lt;= pe.maxSpansPerSecond </span><span class="cov4" title="17">{
                pe.spansInCurrentSecond = spansInSecondIfSampled
                return Sampled
        }</span>

        <span class="cov0" title="0">return NotSampled</span>
}

// Evaluate looks at the trace data and returns a corresponding SamplingDecision. Also takes into account
// the usage of sampling rate budget
func (pe *policyEvaluator) Evaluate(traceID pdata.TraceID, trace *TraceData) Decision <span class="cov5" title="36">{
        currSecond := time.Now().Unix()

        if !pe.shouldConsider(currSecond, trace) </span><span class="cov1" title="2">{
                return NotSampled
        }</span>

        <span class="cov5" title="34">decision := pe.evaluateRules(traceID, trace)
        if decision != Sampled </span><span class="cov4" title="17">{
                return decision
        }</span>

        <span class="cov4" title="17">if pe.emitsSecondChance() </span><span class="cov0" title="0">{
                return SecondChance
        }</span>

        <span class="cov4" title="17">return pe.updateRate(currSecond, trace.SpanCount)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
