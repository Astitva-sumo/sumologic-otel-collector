
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>sourceprocessor: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/open-telemetry/opentelemetry-collector-contrib/processor/sourceprocessor/factory.go (50.0%)</option>
				
				<option value="file1">github.com/open-telemetry/opentelemetry-collector-contrib/processor/sourceprocessor/observability/observability.go (16.7%)</option>
				
				<option value="file2">github.com/open-telemetry/opentelemetry-collector-contrib/processor/sourceprocessor/source_processor.go (88.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2019 OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package sourceprocessor

import (
        "context"

        "go.opentelemetry.io/collector/component"
        "go.opentelemetry.io/collector/config"
        "go.opentelemetry.io/collector/consumer"
        "go.opentelemetry.io/collector/processor/processorhelper"
)

const (
        // The value of "type" key in configuration.
        typeStr = "source"

        defaultSource    = "traces"
        defaultCollector = ""

        defaultSourceName                = "%{namespace}.%{pod}.%{container}"
        defaultSourceCategory            = "%{namespace}/%{pod_name}"
        defaultSourceCategoryPrefix      = "kubernetes/"
        defaultSourceCategoryReplaceDash = "/"

        defaultAnnotationPrefix   = "pod_annotation_"
        defaultContainerKey       = "container"
        defaultNamespaceKey       = "namespace"
        defaultPodIDKey           = "pod_id"
        defaultPodKey             = "pod"
        defaultPodNameKey         = "pod_name"
        defaultPodTemplateHashKey = "pod_labels_pod-template-hash"
        defaultSourceHostKey      = "source_host"
)

// NewFactory returns a new factory for the Span processor.
func NewFactory() component.ProcessorFactory <span class="cov8" title="7">{
        return processorhelper.NewFactory(
                typeStr,
                createDefaultConfig,
                processorhelper.WithTraces(createTraceProcessor))
}</span>

// createDefaultConfig creates the default configuration for processor.
func createDefaultConfig() config.Processor <span class="cov10" title="9">{
        return &amp;Config{
                ProcessorSettings: &amp;config.ProcessorSettings{
                        TypeVal: typeStr,
                        NameVal: typeStr,
                },
                Source:                    defaultSource,
                Collector:                 defaultCollector,
                SourceName:                defaultSourceName,
                SourceCategory:            defaultSourceCategory,
                SourceCategoryPrefix:      defaultSourceCategoryPrefix,
                SourceCategoryReplaceDash: defaultSourceCategoryReplaceDash,

                AnnotationPrefix:   defaultAnnotationPrefix,
                ContainerKey:       defaultContainerKey,
                NamespaceKey:       defaultNamespaceKey,
                PodKey:             defaultPodKey,
                PodIDKey:           defaultPodIDKey,
                PodNameKey:         defaultPodNameKey,
                PodTemplateHashKey: defaultPodTemplateHashKey,
                SourceHostKey:      defaultSourceHostKey,
        }
}</span>

// CreateTraceProcessor creates a trace processor based on this config.
func createTraceProcessor(
        _ context.Context,
        _ component.ProcessorCreateParams,
        cfg config.Processor,
        nextConsumer consumer.Traces) (component.TracesProcessor, error) <span class="cov0" title="0">{

        oCfg := cfg.(*Config)
        return newSourceTraceProcessor(nextConsumer, oCfg), nil
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2019 Omnition Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package observability

import (
        "context"

        "go.opencensus.io/stats"
        "go.opencensus.io/stats/view"
)

func init() <span class="cov8" title="1">{
        view.Register(
                viewResourceSpansProcessed,
                viewRecordsFilteredOut,
                viewRecordsFilteredIn,
        )
}</span>

var (
        mResouceSpansProcessed = stats.Int64("otelsvc/sumo/resource_spans_processed", "Number of record span packages processed", "1")
        mRecordsFilteredOut    = stats.Int64("otelsvc/sumo/records_filtered_out", "Number of records filtered out", "1")
        mRecordsFilteredIn     = stats.Int64("otelsvc/sumo/records_filtered_in", "Number of records filtered in", "1")
)

var viewResourceSpansProcessed = &amp;view.View{
        Name:        mResouceSpansProcessed.Name(),
        Description: mResouceSpansProcessed.Description(),
        Measure:     mResouceSpansProcessed,
        Aggregation: view.Sum(),
}

var viewRecordsFilteredOut = &amp;view.View{
        Name:        mRecordsFilteredOut.Name(),
        Description: mRecordsFilteredOut.Description(),
        Measure:     mRecordsFilteredOut,
        Aggregation: view.Sum(),
}

var viewRecordsFilteredIn = &amp;view.View{
        Name:        mRecordsFilteredIn.Name(),
        Description: mRecordsFilteredIn.Description(),
        Measure:     mRecordsFilteredIn,
        Aggregation: view.Sum(),
}

// RecordResourceSpansProcessed increments the metric that resource spans package was processed
func RecordResourceSpansProcessed() <span class="cov0" title="0">{
        stats.Record(context.Background(), mResouceSpansProcessed.M(int64(1)))
}</span>

// RecordFilteredOut increments the metric that records record filtered out
func RecordFilteredOut() <span class="cov0" title="0">{
        stats.Record(context.Background(), mRecordsFilteredOut.M(int64(1)))
}</span>

// RecordFilteredOutN increments the metric that records record filtered out
func RecordFilteredOutN(n int) <span class="cov0" title="0">{
        stats.Record(context.Background(), mRecordsFilteredOut.M(int64(n)))
}</span>

// RecordFilteredIn increments the metric that records record filtered in
func RecordFilteredIn() <span class="cov0" title="0">{
        stats.Record(context.Background(), mRecordsFilteredIn.M(int64(1)))
}</span>

// RecordFilteredInN increments the metric that records record filtered in
func RecordFilteredInN(n int) <span class="cov0" title="0">{
        stats.Record(context.Background(), mRecordsFilteredIn.M(int64(n)))
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright 2019 OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package sourceprocessor

import (
        "context"
        "fmt"
        "log"
        "regexp"
        "strings"

        "go.opentelemetry.io/collector/component"
        "go.opentelemetry.io/collector/consumer"
        "go.opentelemetry.io/collector/consumer/pdata"

        "github.com/open-telemetry/opentelemetry-collector-contrib/processor/sourceprocessor/observability"
)

type sourceTraceKeys struct {
        annotationPrefix   string
        containerKey       string
        namespaceKey       string
        podKey             string
        podIDKey           string
        podNameKey         string
        podTemplateHashKey string
        sourceHostKey      string
}

func (stk sourceTraceKeys) convertKey(key string) string <span class="cov9" title="52">{
        switch key </span>{
        case "container":<span class="cov5" title="10">
                return stk.containerKey</span>
        case "namespace":<span class="cov7" title="20">
                return stk.namespaceKey</span>
        case "pod":<span class="cov5" title="10">
                return stk.podKey</span>
        case "pod_id":<span class="cov2" title="2">
                return stk.podIDKey</span>
        case "pod_name":<span class="cov5" title="10">
                return stk.podNameKey</span>
        case "source_host":<span class="cov0" title="0">
                return stk.sourceHostKey</span>
        default:<span class="cov0" title="0">
                return key</span>
        }
}

type attributeFiller struct {
        name            string
        compiledFormat  string
        dashReplacement string
        prefix          string
        labels          []string
}

type sourceTraceProcessor struct {
        collector             string
        source                string
        sourceCategoryFiller  attributeFiller
        sourceNameFiller      attributeFiller
        sourceHostFiller      attributeFiller
        excludeNamespaceRegex *regexp.Regexp
        excludePodRegex       *regexp.Regexp
        excludeContainerRegex *regexp.Regexp
        excludeHostRegex      *regexp.Regexp
        nextConsumer          consumer.Traces
        keys                  sourceTraceKeys
}

const (
        alphanums = "bcdfghjklmnpqrstvwxz2456789"

        sourceHostSpecialAnnotation     = "sumologic.com/sourceHost"
        sourceNameSpecialAnnotation     = "sumologic.com/sourceName"
        sourceCategorySpecialAnnotation = "sumologic.com/sourceCategory"

        includeAnnotation = "sumologic.com/include"
        excludeAnnotation = "sumologic.com/exclude"

        collectorKey      = "_collector"
        sourceCategoryKey = "_sourceCategory"
        sourceHostKey     = "_sourceHost"
        sourceNameKey     = "_sourceName"
)

func compileRegex(regex string) *regexp.Regexp <span class="cov8" title="40">{
        if regex == "" </span><span class="cov8" title="36">{
                return nil
        }</span>

        <span class="cov3" title="4">re, err := regexp.Compile(regex)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Cannot compile regular expression: %s Error: %v\n", regex, err)
        }</span>

        <span class="cov3" title="4">return re</span>
}

func matchRegexMaybe(re *regexp.Regexp, atts pdata.AttributeMap, attributeName string) bool <span class="cov9" title="46">{
        if re == nil </span><span class="cov8" title="39">{
                return false
        }</span>

        <span class="cov5" title="7">if attrValue, found := atts.Get(attributeName); found </span><span class="cov3" title="3">{
                if attrValue.Type() == pdata.AttributeValueSTRING </span><span class="cov3" title="3">{
                        return re.MatchString(attrValue.StringVal())
                }</span>
        }

        <span class="cov3" title="4">return false</span>
}

func newSourceTraceProcessor(next consumer.Traces, cfg *Config) *sourceTraceProcessor <span class="cov5" title="10">{
        keys := sourceTraceKeys{
                annotationPrefix:   cfg.AnnotationPrefix,
                containerKey:       cfg.ContainerKey,
                namespaceKey:       cfg.NamespaceKey,
                podIDKey:           cfg.PodIDKey,
                podKey:             cfg.PodKey,
                podNameKey:         cfg.PodNameKey,
                podTemplateHashKey: cfg.PodTemplateHashKey,
                sourceHostKey:      cfg.SourceHostKey,
        }

        return &amp;sourceTraceProcessor{
                nextConsumer:          next,
                collector:             cfg.Collector,
                keys:                  keys,
                source:                cfg.Source,
                sourceHostFiller:      createSourceHostFiller(),
                sourceCategoryFiller:  createSourceCategoryFiller(cfg, keys),
                sourceNameFiller:      createSourceNameFiller(cfg, keys),
                excludeNamespaceRegex: compileRegex(cfg.ExcludeNamespaceRegex),
                excludeHostRegex:      compileRegex(cfg.ExcludeHostRegex),
                excludeContainerRegex: compileRegex(cfg.ExcludeContainerRegex),
                excludePodRegex:       compileRegex(cfg.ExcludePodRegex),
        }
}</span>

func (stp *sourceTraceProcessor) fillOtherMeta(atts pdata.AttributeMap) <span class="cov5" title="10">{
        if stp.collector != "" </span><span class="cov5" title="10">{
                atts.UpsertString(collectorKey, stp.collector)
        }</span>
}

func (stp *sourceTraceProcessor) isFilteredOut(atts pdata.AttributeMap) bool <span class="cov6" title="15">{
        // TODO: This is quite inefficient when done for each package (ore even more so, span) separately.
        // It should be moved to K8S Meta Processor and done once per new pod/changed pod

        if value, found := atts.Get(stp.annotationAttribute(excludeAnnotation)); found </span><span class="cov1" title="1">{
                if value.Type() == pdata.AttributeValueSTRING &amp;&amp; value.StringVal() == "true" </span><span class="cov1" title="1">{
                        return true
                }</span> else<span class="cov0" title="0"> if value.Type() == pdata.AttributeValueBOOL &amp;&amp; value.BoolVal() </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov6" title="14">if value, found := atts.Get(stp.annotationAttribute(includeAnnotation)); found </span><span class="cov1" title="1">{
                if value.Type() == pdata.AttributeValueSTRING &amp;&amp; value.StringVal() == "true" </span><span class="cov1" title="1">{
                        return false
                }</span> else<span class="cov0" title="0"> if value.Type() == pdata.AttributeValueBOOL &amp;&amp; value.BoolVal() </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov6" title="13">if matchRegexMaybe(stp.excludeNamespaceRegex, atts, stp.keys.namespaceKey) </span><span class="cov1" title="1">{
                return true
        }</span>
        <span class="cov6" title="12">if matchRegexMaybe(stp.excludePodRegex, atts, stp.keys.podKey) </span><span class="cov1" title="1">{
                return true
        }</span>
        <span class="cov6" title="11">if matchRegexMaybe(stp.excludeContainerRegex, atts, stp.keys.containerKey) </span><span class="cov1" title="1">{
                return true
        }</span>
        <span class="cov5" title="10">if matchRegexMaybe(stp.excludeHostRegex, atts, stp.keys.sourceHostKey) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov5" title="10">return false</span>
}

func (stp *sourceTraceProcessor) annotationAttribute(annotationKey string) string <span class="cov10" title="74">{
        return stp.keys.annotationPrefix + annotationKey
}</span>

func (stp *sourceTraceProcessor) ConsumeTraces(ctx context.Context, td pdata.Traces) error <span class="cov5" title="10">{
        rss := td.ResourceSpans()

        for i := 0; i &lt; rss.Len(); i++ </span><span class="cov5" title="10">{
                observability.RecordResourceSpansProcessed()

                rs := rss.At(i)
                res := rs.Resource()
                filledAnySource := false
                filledOtherMeta := false

                atts := res.Attributes()

                // TODO: move this to k8sprocessor
                stp.enrichPodName(&amp;atts)
                stp.fillOtherMeta(atts)
                filledOtherMeta = true

                filledAnySource = stp.sourceHostFiller.fillResourceOrUseAnnotation(&amp;atts, stp.annotationAttribute(sourceHostSpecialAnnotation), stp.keys) || filledAnySource
                filledAnySource = stp.sourceCategoryFiller.fillResourceOrUseAnnotation(&amp;atts, stp.annotationAttribute(sourceCategorySpecialAnnotation), stp.keys) || filledAnySource
                filledAnySource = stp.sourceNameFiller.fillResourceOrUseAnnotation(&amp;atts, stp.annotationAttribute(sourceNameSpecialAnnotation), stp.keys) || filledAnySource

                ilss := rs.InstrumentationLibrarySpans()
                totalSpans := 0
                for j := 0; j &lt; ilss.Len(); j++ </span><span class="cov4" title="6">{
                        ils := ilss.At(j)
                        totalSpans = ils.Spans().Len()
                }</span>

                <span class="cov5" title="10">if stp.isFilteredOut(atts) </span><span class="cov1" title="1">{
                        rs.InstrumentationLibrarySpans().Resize(0)
                        observability.RecordFilteredOutN(totalSpans)
                }</span> else<span class="cov5" title="9"> {
                        observability.RecordFilteredInN(totalSpans)
                }</span>

                // Perhaps this is coming through Zipkin and in such case the attributes are stored in each span attributes, doh!
                <span class="cov5" title="10">if !filledAnySource </span><span class="cov5" title="7">{
                        ilss := rs.InstrumentationLibrarySpans()
                        for j := 0; j &lt; ilss.Len(); j++ </span><span class="cov4" title="5">{
                                ils := ilss.At(j)
                                inputSpans := ils.Spans()
                                outputSpans := pdata.NewSpanSlice()

                                for k := 0; k &lt; inputSpans.Len(); k++ </span><span class="cov4" title="5">{
                                        s := inputSpans.At(k)
                                        atts := s.Attributes()

                                        // TODO: move this to k8sprocessor
                                        stp.enrichPodName(&amp;atts)
                                        if !filledOtherMeta </span><span class="cov0" title="0">{
                                                stp.fillOtherMeta(atts)
                                        }</span>

                                        <span class="cov4" title="5">stp.sourceHostFiller.fillResourceOrUseAnnotation(&amp;atts, stp.annotationAttribute(sourceHostSpecialAnnotation), stp.keys)
                                        stp.sourceCategoryFiller.fillResourceOrUseAnnotation(&amp;atts, stp.annotationAttribute(sourceCategorySpecialAnnotation), stp.keys)
                                        stp.sourceNameFiller.fillResourceOrUseAnnotation(&amp;atts, stp.annotationAttribute(sourceNameSpecialAnnotation), stp.keys)

                                        if !stp.isFilteredOut(atts) </span><span class="cov2" title="2">{
                                                outputSpans.Resize(outputSpans.Len() + 1)
                                                s.CopyTo(outputSpans.At(outputSpans.Len() - 1))
                                                observability.RecordFilteredIn()
                                        }</span> else<span class="cov3" title="3"> {
                                                observability.RecordFilteredOut()
                                        }</span>
                                }

                                <span class="cov4" title="5">ils.Spans().Resize(0)
                                outputSpans.MoveAndAppendTo(ils.Spans())</span>
                        }
                }
        }
        <span class="cov5" title="10">return stp.nextConsumer.ConsumeTraces(ctx, td)</span>
}

// GetCapabilities returns the Capabilities assocciated with the resource processor.
func (stp *sourceTraceProcessor) GetCapabilities() component.ProcessorCapabilities <span class="cov2" title="2">{
        return component.ProcessorCapabilities{MutatesConsumedData: true}
}</span>

// Start is invoked during service startup.
func (*sourceTraceProcessor) Start(_context context.Context, _host component.Host) error <span class="cov0" title="0">{
        return nil
}</span>

// Shutdown is invoked during service shutdown.
func (*sourceTraceProcessor) Shutdown(_context context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// Convert the pod_template_hash to an alphanumeric string using the same logic Kubernetes
// uses at https://github.com/kubernetes/apimachinery/blob/18a5ff3097b4b189511742e39151a153ee16988b/pkg/util/rand/rand.go#L119
func SafeEncodeString(s string) string <span class="cov0" title="0">{
        r := make([]byte, len(s))
        for i, b := range []rune(s) </span><span class="cov0" title="0">{
                r[i] = alphanums[(int(b) % len(alphanums))]
        }</span>
        <span class="cov0" title="0">return string(r)</span>
}

func (stp *sourceTraceProcessor) enrichPodName(atts *pdata.AttributeMap) <span class="cov6" title="15">{
        // This replicates sanitize_pod_name function
        // Strip out dynamic bits from pod name.
        // NOTE: Kubernetes deployments append a template hash.
        // At the moment this can be in 3 different forms:
        //   1) pre-1.8: numeric in pod_template_hash and pod_parts[-2]
        //   2) 1.8-1.11: numeric in pod_template_hash, hash in pod_parts[-2]
        //   3) post-1.11: hash in pod_template_hash and pod_parts[-2]

        if atts == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov6" title="15">pod, found := atts.Get(stp.keys.podKey)
        if !found </span><span class="cov5" title="7">{
                return
        }</span>

        <span class="cov5" title="8">podParts := strings.Split(pod.StringVal(), "-")
        if len(podParts) &lt; 2 </span><span class="cov0" title="0">{
                // This is unexpected, fallback
                return
        }</span>

        <span class="cov5" title="8">podTemplateHashAttr, found := atts.Get(stp.keys.podTemplateHashKey)

        if found &amp;&amp; len(podParts) &gt; 2 </span><span class="cov5" title="8">{
                podTemplateHash := podTemplateHashAttr.StringVal()
                if podTemplateHash == podParts[len(podParts)-2] || SafeEncodeString(podTemplateHash) == podParts[len(podParts)-2] </span><span class="cov5" title="8">{
                        atts.UpsertString(stp.keys.podNameKey, strings.Join(podParts[:len(podParts)-2], "-"))
                        return
                }</span>
        }
        <span class="cov0" title="0">atts.UpsertString(stp.keys.podNameKey, strings.Join(podParts[:len(podParts)-1], "-"))</span>
}

func extractFormat(format string, name string, keys sourceTraceKeys) attributeFiller <span class="cov7" title="22">{
        r, _ := regexp.Compile(`\%\{(\w+)\}`)

        labels := make([]string, 0)
        matches := r.FindAllStringSubmatch(format, -1)
        for _, matchset := range matches </span><span class="cov9" title="52">{
                labels = append(labels, keys.convertKey(matchset[1]))
        }</span>
        <span class="cov7" title="22">template := r.ReplaceAllString(format, "%s")

        return attributeFiller{
                name:            name,
                compiledFormat:  template,
                dashReplacement: "",
                labels:          labels,
                prefix:          "",
        }</span>
}

func createSourceHostFiller() attributeFiller <span class="cov5" title="10">{
        return attributeFiller{
                name:            sourceHostKey,
                compiledFormat:  "",
                dashReplacement: "",
                labels:          make([]string, 0),
                prefix:          "",
        }
}</span>

func createSourceNameFiller(cfg *Config, keys sourceTraceKeys) attributeFiller <span class="cov5" title="10">{
        filler := extractFormat(cfg.SourceName, sourceNameKey, keys)
        return filler
}</span>

func createSourceCategoryFiller(cfg *Config, keys sourceTraceKeys) attributeFiller <span class="cov5" title="10">{
        filler := extractFormat(cfg.SourceCategory, sourceCategoryKey, keys)
        filler.compiledFormat = cfg.SourceCategoryPrefix + filler.compiledFormat
        filler.dashReplacement = cfg.SourceCategoryReplaceDash
        filler.prefix = cfg.SourceCategoryPrefix
        return filler
}</span>

func (f *attributeFiller) fillResourceOrUseAnnotation(atts *pdata.AttributeMap, annotationKey string, keys sourceTraceKeys) bool <span class="cov8" title="45">{
        val, found := atts.Get(annotationKey)
        if found </span><span class="cov2" title="2">{
                annotationFiller := extractFormat(val.StringVal(), f.name, keys)
                annotationFiller.dashReplacement = f.dashReplacement
                annotationFiller.compiledFormat = f.prefix + annotationFiller.compiledFormat
                return annotationFiller.fillAttributes(atts)
        }</span>
        <span class="cov8" title="43">return f.fillAttributes(atts)</span>
}

func (f *attributeFiller) fillAttributes(atts *pdata.AttributeMap) bool <span class="cov8" title="45">{
        if len(f.compiledFormat) == 0 </span><span class="cov6" title="14">{
                return false
        }</span>

        <span class="cov8" title="31">labelValues := f.resourceLabelValues(atts)
        if labelValues != nil </span><span class="cov6" title="17">{
                str := fmt.Sprintf(f.compiledFormat, labelValues...)
                if f.dashReplacement != "" </span><span class="cov5" title="8">{
                        str = strings.ReplaceAll(str, "-", f.dashReplacement)
                }</span>
                <span class="cov6" title="17">atts.UpsertString(f.name, str)
                return true</span>
        }
        <span class="cov6" title="14">return false</span>
}

func (f *attributeFiller) resourceLabelValues(atts *pdata.AttributeMap) []interface{} <span class="cov8" title="31">{
        arr := make([]interface{}, 0)
        for _, label := range f.labels </span><span class="cov9" title="54">{
                value, ok := atts.Get(label)
                if !ok </span><span class="cov6" title="14">{
                        return nil
                }</span>
                <span class="cov8" title="40">arr = append(arr, value.StringVal())</span>
        }
        <span class="cov6" title="17">return arr</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
